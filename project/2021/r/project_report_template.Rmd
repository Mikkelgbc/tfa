---
title: "Seat reservation"
description: |
  R project - An analysis of seat reservation strategies
date: "`r Sys.Date()`"
author:
  - name: [First author name]
    #url: https://example.com/norajones
    affiliation: cand.merc (OSCM)
    #affiliation_url: https://example.com/spacelysprokets
  - name: [Second author name]
    affiliation: cand.merc (?)
  - name: [Third author name]
    affiliation: cand.merc (?)
creative_commons: CC BY-NC
output:
  distill::distill_article:
    toc: true
    toc_depth: 3
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tidyverse)
library(readxl)
library(jsonlite)

if (interactive()) setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set working dir to current file location
knitr::opts_chunk$set(
  cache = TRUE, autodep = TRUE,  # use this option so compile the document faster (you may comment it out at the final report)
  echo = FALSE, 
  layout="l-page", fig.width = 12
  )
# options(width = 150)
# use xaringan::inf_mr() for instant preview

q_ctr <- 1  # question counter
ctrQ <- function(reset = FALSE) {
  if (reset) q_ctr <<- 1
  q_ctr <<- q_ctr + 1
  return(str_c("Question ", q_ctr - 1, ""))
}
```

<!-- Some css for the comments (delete) -->
```{css, echo=FALSE}
.comment {
  color: #F1948A;
  border-color: black;
  border-style: dashed;
  border-width: thin;
  padding: 10px;
}
```

A template file for this assignment is given which may be used as a starting point. The file already contains chunks for some of the questions. Solve the assignment using the desktop version of RStudio. Hand in a zip file with your project folder.

This assignment considers a seat reservation problem. Consider a train with $I$ seats that is traveling between a start station $1$ and an end station $S$ with $S-2$ stations in between. All seats must be reserved and requests for seat reservations arrive on-line. For ease we assume that a request $r$ is for a single seat between a start station $s_1(r)$ and the end station $s_2(r)$. A decision must be made immediately after the arrival of the request to either accept the request or reject it. If the request is accepted, the reservation must be allocated to a seat and this decision cannot be changed subsequently. That is, there is no knowledge about future requests. The train company want to find a strategy that accept as many requests as possible. 


### Data handling

#### `r ctrQ()` 

The Excel file `data.xlsx` contains 9 sheets with data named `Data-<n>`. Create 9 json files named `data-1.json` to `data-9.json` with the data. Hint: you have to save `seats`, `stations` and `requests` in a list and then save the list as a json file. 
  
```{r save-to-json}
library(tidyverse)
library(readxl)
library(jsonlite)

## See https://bss-osca.github.io/tfa/mod-r-io.html#r-io-json
# for (i in 1:9) {
#   sheetName <- paste0("Data-", i)
#   lst <- list(
#     seats = ___,
#     stations = ___,
#     requests = ___
#   )
#   write_json(___)
# }
```

#### `r ctrQ()` 

Store information about each data file in a tibble containing variables/columns:
  
- File name.
- Seats
- Stations
- Number of requests
- Requests (data frame/tibble). A data frame `df` can be added as a list. 
- Route. The train route considered (we assume a route is unique for each seats, stations pair).
- Average request length. Given a request in the `requests` tibble, the length is `To - From`.
- Relative number of requests for a slot. Given a slot the number of requests for that slot is the number of requests where the slot is contained in the route from `From` to `To`. The relative number is obtained by dividing with the sum.
  
```{r build-req-tibble}
# dat <- NULL
# for (i in 1:9) { 
#   fileN <- paste0("data-",i,".json")
#   ins <- read_json(___)
#   dat <- dat %>% 
#     bind_rows(
#       tibble(
#         name = fileN, 
#         seats = ins$seats,
#         stations = ins$stations,
#         reqLth = nrow(ins$requests),
#         requests = list(ins$requests)
#       )
#     )
# }
# 
# dat <- dat %>% 
#   group_by(name) %>% 
#   mutate(route = paste0("Route ", cur_group_id(), " (Seats: ", seats, ", Stations: ", stations, ")")) 

## To find aveReqLth you may use the map_dbl function to apply a function to each element in a list (instead of a for loop). 
## To give an example let us define a tibble:
# dat <- tibble(x = 1:2, y = c("Ok", "Fine"), z = NA)
# dat$z[1] = list(tibble(a = c(4,5), b = c(8,9)))
# dat$z[2] = list(tibble(a = c(1,5,7), b = c(8,12,10)))
# dat
# # Then we apply a function to each tibble (df) in the z column:
# dat <- dat %>% 
#   mutate(ave = map_dbl(z, .f = function(df) {
#     val <- df %>%    # df is the tibbles in the z column (analysed one at a time)
#       mutate(l = b - a) %>%   # define a new col with the difference
#       pull(l) %>%    # extract that colum as a vector
#       mean()         # take the mean
#     return(val)
#   }))
# dat

## To find reqSlots you may use the map2 function instead of a for loop:
# dat <- dat %>%
#   mutate(reqSlots = map2(
#     requests, # apply row elements from requests (a tibble) 
#     stations, # apply row elements from stations (an integer) 
#     .f = function(df, st) { # df refer to the value in the requests column and st to the value in the stations column
#       res <- tibble(slot = 1:(st - 1), n = rep(0, st - 1))
#       for (i in 1:nrow(df)) {
#         idx <- df$From[i]:(df$To[i] - 1)
#         res$n[idx] <- res$n[idx] + 1
#       }
#       res <- res %>% mutate(pct = ___)
#       return(res)
#     }
#   )) 
```

#### `r ctrQ()` 

Plot the distribution of requests for each route (facet). Hint here it may be useful to do a `dat %>% unnest(c(reqSlots))` first. 

```{r}
# dat %>%
#   unnest(c(reqSlots)) %>%
#   ggplot(aes(___)) +
#   geom_col() +
#   facet_wrap(___)
```


### Algorithm implementation

Given a request $r$ we use the **Minimize Slots (MinSlots)** strategy: For each seat $i$ available from $s_1(r)$ to $s_2(r)$ calculate the total free slots before and after stations $s_1$ to $s_2$. Assign the request to a seat where it leaves as little total free slots as possible. Otherwise reject the request.


#### `r ctrQ()` 

Implement the strategy as a function `MinSlots` that takes a dataset and returns the solution as a list. 

Statistics used to measure the quality of the strategy are:

- Accepted requests in percent.
- Total usage of slots in percent. That is, slots used divided with total number of slots.
- Usage of each slot in percent. That is, usage of a slot divided with seats.
- Usage of each seat in percent. That is, usage of a seat divided with slots.
  
```{r}
## Try analyse the code (e.g. run a line at a time) and fill in the missing. Use F1 to get help about unknown functions. 
# MinSlots <- function(dat) {
#   accepted <- 0
#   used <- 0
#   requests <- dat$requests %>% mutate(Seat = NA)
#   seats <- dat$seats
#   stations <- dat$stations
#   sol <- matrix(NA, nrow = seats, ncol = stations-1) # sol[i, s] = r if seat i is taken by request r from station interval s to s+1; otherwise 0
#   for (r in 1:nrow(requests)) {
#       from = ___
#       to = ___ - 1 # since only need station interval s-1 to s
#       # cat("r=",r,"\n")
#       okaySeats <- which(apply(sol[, from:to, drop=F], 1, function(x) all(is.na(x))))
#       if (length(okaySeats) > 0) {
#           # print(okaySeats)
#           # print(sol)
#           # print(from:to)
#           seat <- okaySeats[which.min(apply(sol[okaySeats, , drop = F], 1, function(x) FreeSlots(x, from:to)))]
#           # print(seat)
#           sol[seat, from:to] <- r
#           requests$Seat[r] <- seat
#           used <- ___
#           accepted = ___
#       }
#       # print(warnings())
#   }
#   accepted <- ___
#   requests <- requests %>% mutate(Request = row_number())
#   usageSeats <- tibble(seat = ___, pct = rowSums(!is.na(sol))/ncol(sol))
#   usageSlots <- tibble(slot = ___, pct = colSums(!is.na(sol))/nrow(sol))
#   usage <- ___
#   return(list(allocation = requests, accepted = accepted, usage = usage, usageSeats = usageSeats, usageSlots = usageSlots, mat = sol))
# }


#' Find number of free slots before and after a slot range
#'
#' @param alloc Current allocation.
#' @param range Slot range.
#'
#' @return Number of free slots before and after,
#' @export
#'
#' @examples
FreeSlots <- function(alloc, range) {
  ctr <- 0
  for (i in (min(range) - 1):1) {
    if (i == 0) break
    if (is.na(alloc[i])) ctr <- ctr + 1 else break
  }
  for (i in (max(range) + 1):length(alloc)) {
    if (i == length(alloc) + 1) break
    if (is.na(alloc[i])) ctr <- ctr + 1 else break
  }
  return(ctr)
}
```

#### `r ctrQ()` 

Create a function `PlotSolution` that takes `solution` as input and plot the solution. Plot the solution for instance file `data-1.json`.
  
```{r, include=FALSE}
# plotSolution <- function(solution) {
#   plt <- ggplot(solution$allocation %>% filter(!is.na(Seat)), aes(___) +
#     geom_segment(size = 10) +  # have a look at the documentation for this function
#     geom_text(aes(___), color = "white") +
#     ___
#   return(plt)
# }
```
  
#### `r ctrQ()` 

Solve all the instances/data files and add the results to your tibble from Question 2. 

```{r, include=FALSE}
# dat <- NULL
# for (i in 1:9) { 
#   fileN <- paste0("data-",i,".json")
#   ins <- read_json(fileN, simplifyDataFrame = T, simplifyVector = T)
#   solution <- MinSlots(ins)
#   dat <- dat %>% 
#     bind_rows(
#       tibble(
#         name = fileN, 
#         seats = ins$seats,
#         stations = ins$stations,
#         reqLth = nrow(ins$requests),
#         requests = list(ins$requests),
#         allocation = list(solution$allocation),
#         accepted = ___
#         ___
#       )
#     )
# }

## More code
```

#### `r ctrQ()`  

Plot the usage of slots for each route (facet) and the usage of seats for each route (facet).

```{r, fig.cap="Usage of time slots (if equal 1 then all seats are used in that slot).", fig.asp=1}
# dat %>% 
#   unnest(c(usageSlots)) %>% 
#   ggplot(__) +
#   ___
```

```{r, fig.asp=1, fig.cap="Usage of seats (if equal 1 than the seat is used in all time slots)."}

```
  
  
### Analysis of a larger dataset

The sub folder `data` contains data files (instances) from 4 routes (a route is identified by a unique seat, stations pair). Note you here have different datasets for the same route (e.g. from different days).

#### `r ctrQ()` 

Solve all the instances a store all the results in a tibble. How many instances are there for each route?

```{r}
files <- list.files(path = "data", full.names = T)
dat <- NULL

## More code
```




#### `r ctrQ()` 

Analyse the requests for each route, e.g. accepted, average length and distribution among time slots. Comment on the results.

Average results for requests:

```{r}

```

Distribution of requests:

```{r}

```



#### `r ctrQ()` 

Analyse the usage of the routes, e.g. usage, usage of seats and usage of slots. Comment on the results.

Average usage:

```{r}

```

Usage of seats:

```{r}

```

Usage of slots:

```{r}

```

#### `r ctrQ()` 

Analyse the usage of the routes, e.g. usage, usage of seats and usage of slots. Comment on the results.

Tendency for each route: 

```{r}

```

