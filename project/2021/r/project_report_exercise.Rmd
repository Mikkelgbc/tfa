---
title: "Seat reservation"
description: |
  R project - An analysis of seat reservation strategies
date: "`r Sys.Date()`"
#repository_url: [A url to your source code(dropbox, onedrive, github etc)]
#preview: https://rstudio.github.io/distill/images/javascript-d3-preview.png
# creative_commons: CC BY-NC
bibliography: litt.bib
output:
  distill::distill_article:
    toc: true
    toc_depth: 3
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tidyverse)
library(readxl)
library(jsonlite)

if (interactive()) setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set working dir to current file location
knitr::opts_chunk$set(
  cache = TRUE, autodep = TRUE,  # use this option so compile the document faster (you may comment it out at the final report)
  echo = FALSE, 
  layout="l-page", fig.width = 12
  )
# options(width = 150)
# use xaringan::inf_mr() for instant preview

q_ctr <- 1  # question counter
ctrQ <- function(reset = FALSE) {
  if (reset) q_ctr <<- 1
  q_ctr <<- q_ctr + 1
  return(str_c("Question ", q_ctr - 1, ""))
}
```

<!-- Some css for the comments (delete) -->
```{css, echo=FALSE}
.comment {
  color: #F1948A;
  border-color: black;
  border-style: dashed;
  border-width: thin;
  padding: 10px;
}
```

A template file for this assignment is given which may be used as a starting point. The file already contains unfinished chunks for some of the questions. Solve the assignment using the desktop version of RStudio. Hand in a zip file with your project folder.

This assignment considers a seat reservation problem. Consider a train with $I$ seats that is traveling between a start station $1$ and an end station $S$ with $S-2$ stations in between. All seats must be reserved and requests for seat reservations arrive on-line. For ease we assume that a request $r$ is for a single seat between a start station $s_1(r)$ and the end station $s_2(r)$. A decision must be made immediately after the arrival of the request to either accept the request or reject it. If the request is accepted, the reservation must be allocated to a seat and this decision cannot be changed subsequently. That is, there is no knowledge about future requests. The train company want to find a strategy that accept as many requests as possible. Consider the following requests arriving for a train with 3 seats and 14 stations:

```{r, echo=FALSE, layout="l-body"}
library(tidyverse)
library(kableExtra)
library(jsonlite)

read_json("data-4.json", simplifyDataFrame = T, simplifyVector = T)$requests %>% 
  mutate(Request = row_number()) %>% 
  relocate(Request, .before = From) %>% 
  kbl(align = "c") %>% 
  kable_styling()
```

```{r, include=FALSE}
Greedy <- function(dat) {
  accepted <- 0
  used <- 0
  requests <- dat$requests %>% mutate(Seat = NA)
  seats <- dat$seats
  stations <- dat$stations
  sol <- matrix(NA, nrow = seats, ncol = stations-1) # sol[i, s] = r if seat i is taken by request r from station interval s to s+1; otherwise 0
  for (r in 1:nrow(requests)) {
      from = requests[r, 1]
      to = requests[r, 2] - 1 # since only need station interval s-1 to s
      # cat("r=",r,"\n")
      okaySeats <- which(apply(sol[, from:to, drop=F], 1, function(x) all(is.na(x))))
      if (length(okaySeats) > 0) {
          seat <- min(okaySeats)
          sol[seat, from:to] <- r
          requests$Seat[r] <- seat
          used <- used + to - from + 1
          accepted = accepted + 1
      }
  }
  accepted <- accepted/nrow(requests)
  requests <- requests %>% mutate(Request = row_number()) 
  return(list(allocation = requests , accepted = accepted, used = used / (seats * (stations - 1)), mat = sol))
}

MinSlots <- function(dat) {
  accepted <- 0
  used <- 0
  requests <- dat$requests %>% mutate(Seat = NA)
  seats <- dat$seats
  stations <- dat$stations
  sol <- matrix(NA, nrow = seats, ncol = stations-1) # sol[i, s] = r if seat i is taken by request r from station interval s to s+1; otherwise 0
  for (r in 1:nrow(requests)) {
      from = requests[r, 1]
      to = requests[r, 2] - 1 # since only need station interval s-1 to s
      # cat("r=",r,"\n")
      okaySeats <- which(apply(sol[, from:to, drop=F], 1, function(x) all(is.na(x))))
      if (length(okaySeats) > 0) {
          # print(okaySeats)
          # print(sol)
          # print(from:to)
          seat <- okaySeats[which.min(apply(sol[okaySeats, , drop = F], 1, function(x) FreeSlots(x, from:to)))]
          # print(seat)
          sol[seat, from:to] <- r
          requests$Seat[r] <- seat
          used <- used + to - from + 1
          accepted = accepted + 1
      }
      # print(warnings())
  }
  accepted <- accepted/nrow(requests)
  requests <- requests %>% mutate(Request = row_number())
  usageSeats <- tibble(seat = 1:seats, pct = rowSums(!is.na(sol))/ncol(sol))
  usageSlots <- tibble(slot = 1:(stations-1), pct = colSums(!is.na(sol))/nrow(sol))
  usage <- used / (seats * (stations - 1))
  return(list(allocation = requests, accepted = accepted, usage = usage, usageSeats = usageSeats, usageSlots = usageSlots, mat = sol))
}


FreeSlots <- function(alloc, range) {
  ctr <- 0
  for (i in (min(range) - 1):1) {
    if (i == 0) break
    if (is.na(alloc[i])) ctr <- ctr + 1 else break
  }
  for (i in (max(range) + 1):length(alloc)) {
    if (i == length(alloc) + 1) break
    if (is.na(alloc[i])) ctr <- ctr + 1 else break
  }
  return(ctr)
}
```


```{r, include=FALSE}
plotSolution <- function(solution) {
  plt <- ggplot(solution$allocation %>% filter(!is.na(Seat)), aes(x = From, xend = To, y = Seat, yend = Seat, color = factor(Request))) +
    geom_segment(size = 10) +
    geom_text(aes(x = From + (To-From)/2, y = Seat, label = Request), color = "white") +
    scale_y_continuous(breaks = 1:max(solution$allocation$Seat, na.rm = T), limits = c(0.5, max(solution$allocation$Seat, na.rm = T) + 0.5)) +
    scale_x_continuous(breaks = 1:max(solution$allocation$To)) +
    labs(y = 'Seat', x = 'Station') +
    theme_bw() + 
    theme(panel.grid.minor = element_blank(), legend.position = "none") 
  return(plt)
}
```

A possible allocation of requests to seats is given in Figure \@ref(fig:min-slots). Observe that the reservation number is assigned to a slot where slot $s$ is from station $s$ to $s+1$. That is, for each seat there is $S-1$ slots. 

```{r min-slots, echo = FALSE, layout="l-body-outset", fig.cap="Assignment of requests. Numbers indicate request number.", fig.height=8, fig.asp=0.2} 
dat <- read_json("data-4.json", simplifyDataFrame = T, simplifyVector = T)
solution <- MinSlots(dat)
plotSolution(solution)
```

For further references about the seat reservation problem see @Boyar99 and @Boyar04. 


### Data handling

#### `r ctrQ()` 

The Excel file `data.xlsx` contains 9 sheets with data named `Data-<n>`. Create 9 json files named `data-1.json` to `data-9.json` with the data. 
  
```{r save-to-json}
library(tidyverse)
library(readxl)
library(jsonlite)

for (i in 1:9) {
  sheetName <- paste0("Data-", i)
  lst <- list(
    seats = read_excel("data.xlsx", sheet = sheetName, range = "B1:B1", col_names = F) %>% pull(),
    stations = read_excel("data.xlsx", sheet = sheetName, range = "B2:B2", col_names = F) %>% pull(),
    requests = read_excel("data.xlsx", sheet = sheetName, range = "B4:C10000") %>% drop_na()
  )
  write_json(lst, paste0(tolower(sheetName), ".json"), pretty = T)
}
```

#### `r ctrQ()` 

Store information about each data file in a tibble containing variables/columns:
  
- File name.
- Seats
- Stations
- Number of requests
- Requests (data frame/tibble). 
- Route. The train route considered (we assume a route is unique for each seats, stations pair).
- Average request length. Given a request in the `requests` tibble, the length is `To - From`.
- Relative number of requests for a slot. Given a slot the number of requests for that slot is the number of requests where the slot is contained in the `From` to `To`. The relative number is obtained by dividing with the sum.
  
```{r build-req-tibble}
dat <- NULL
for (i in 1:9) { 
  fileN <- paste0("data-",i,".json")
  ins <- read_json(fileN, simplifyDataFrame = T, simplifyVector = T)
  dat <- dat %>% 
    bind_rows(
      tibble(
        name = fileN, 
        seats = ins$seats,
        stations = ins$stations,
        reqLth = nrow(ins$requests),
        requests = list(ins$requests)
      )
    )
}

dat <- dat %>% 
  group_by(name) %>% 
  mutate(route = paste0("Route ", cur_group_id(), " (Seats: ", seats, ", Stations: ", stations, ")")) 

dat <- dat %>% 
  mutate(aveReqLth = map_dbl(requests, .f = function(df) {
    df %>% 
      mutate(l = To - From) %>% 
      pull(l) %>% mean()
  }))

dat <- dat %>% 
  mutate(reqSlots = map2(requests, stations, .f = function(df, st) {
    res <- tibble(slot = 1:(st-1), n = rep(0, st-1)) 
    for (i in 1:nrow(df)) {
      idx <- df$From[i]:(df$To[i]-1)
      res$n[idx] <- res$n[idx] + 1
    }
    res <- res %>% mutate(pct = n/sum(n)) 
    return(res)
  })) 
```

The output should be something similar to (only first 2 rows shown)

```{r}
dat %>% ungroup() %>% slice_head(n = 2)
```

where `requests` contains the request tibbles e.g. for the first dataset the first 6 observations are:

```{r, echo=TRUE}
head(dat$requests[[1]])
```

and `reqSlots` the relative number of requests per slot:

```{r, echo=TRUE}
head(dat$reqSlots[[1]])
```

#### `r ctrQ()` 

Plot the distribution of requests for each route (facet). Hint here it may be useful to do a `dat %>% unnest(c(reqSlots))` first. For example the plot (for the first two routes) may look like:

```{r}
dat %>%
  filter(str_detect(route, "Route 1|Route 2")) %>% 
  unnest(c(reqSlots)) %>%
  ggplot(aes(x = slot, y = pct)) +
  geom_col() +
  facet_wrap(vars(route), scales = "free")
```


### Algorithm implementation

Given a request $r$ we use the **Minimize Slots** strategy: For each seat $i$ available from $s_1(r)$ to $s_2(r)$ calculate the total free slots before and after stations $s_1$ to $s_2$. Assign the request to a seat where it leaves as little total free slots as possible. Otherwise reject the request.

#### `r ctrQ()` 

Implement the strategy as a function `MinSlots` that takes a dataset and returns the solution as a list. For instance, the output may be:

```{r, echo=TRUE}
ins <- read_json("data-4.json", simplifyDataFrame = T, simplifyVector = T)
solution <- MinSlots(ins)
solution
```

Statistics used to measure the quality of the strategy are:

- Accepted requests in percent.
- Total usage of slots in percent. That is, slots used divided with total number of slots.
- Usage of each slot in percent. That is, usage of a slot divided with seats.
- Usage of each seat in percent. That is, usage of a seat divided with slots.
  
#### `r ctrQ()` 

Create a function `PlotSolution` that takes `solution` as input and plot the solution similar to as in Figure \@ref(fig:min-slots). Plot the solution for instance file `data-1.json`.
  
#### `r ctrQ()` 

Solve all the instances/data files and add the results to your tibble from Question 2. 

#### `r ctrQ()`  

Plot the usage of slots for each route (facet) and the usage of seats for each route (facet).
  
  
  
### Analysis of a larger dataset
  
```{r, eval=FALSE}
GenerateData <- function(seats, stations, meanFac = c(0.45, 0.55), sd = c(3, 3), req = sample((3*seats):(4*seats), 1)) {
  requests <- tibble(From = rep(NA,req), To = rep(NA,req))
  for (i in 1:req) {
    if (i %% 2 == 0) {
      st <- c(1, 1)
      while (st[1] == st[2]) st <- sample(stations, 2)
    } else {
      st <- c(1, 1)
      while (st[1] == st[2] | st[1] < 1 | st[2] < 1 | st[1] > stations | st[2] > stations){
        st[1] <- round(rnorm(1, stations * meanFac[1], sd[1]))
        st[2] <- round(rnorm(1, stations * meanFac[2], sd[2]))
      }
    }
    requests[i,1] <- min(st)
    requests[i,2] <- max(st)
  }
  return(list(seats = seats, stations = stations, requests = requests))
}
GenerateDataUnif <- function(seats, stations, req = sample((3*seats):(4*seats), 1)) {
  requests <- tibble(From = rep(NA,req), To = rep(NA,req))
  for (i in 1:req) {
    st <- c(1, 1)
    while (st[1] == st[2]) st <- sample(stations, 2)
    requests[i,1] <- min(st)
    requests[i,2] <- max(st)
  }
  return(list(seats = seats, stations = stations, requests = requests))
}


#     gen 150 datasets from 3 train routes analyse the results 
# 1. route
set.seed(4364)
seats <- 23
stations <- 8
for (i in 1:23) {
  lst <- GenerateDataUnif(seats, stations, req = sample(65:320, 1))
  write_json(lst, paste0("data/r1-", seats, "-", stations, "-", nrow(lst$requests), ".json"), pretty = T)
}
# 2. route
seats <- 65
stations <- 12
for (i in 1:17) {
  lst <- GenerateData(seats, stations, meanFac = c(0.02, 0.3), sd = c(0.1, 2), req = sample(200:450, 1))
  write_json(lst, paste0("data/r2-", seats, "-", stations, "-", nrow(lst$requests), ".json"), pretty = T)
}
for (i in 1:18) {
  lst <- GenerateData(seats, stations, meanFac = c(0.8, 1), sd = c(2, 0.1), req = sample(200:450, 1))
  write_json(lst, paste0("data/r2-", seats, "-", stations, "-", nrow(lst$requests), ".json"), pretty = T)
}
# 3. route
seats <- 150
stations <- 21
for (i in 1:15) {
  lst <- GenerateData(seats, stations, meanFac = c(0.7, 0.9), sd = c(2, 1), req = sample(300:600, 1))
  write_json(lst, paste0("data/r3-", seats, "-", stations, "-", nrow(lst$requests), ".json"), pretty = T)
}
# 4. route
seats <- 400
stations <- 32
for (i in 1:25) {
  lst <- GenerateData(seats, stations, meanFac = c(0.1, 0.7), sd = c(2, 5), req = sample(1300:2100, 1))
  write_json(lst, paste0("data/r4-", seats, "-", stations, "-", nrow(lst$requests), ".json"), pretty = T)
}
```

The sub folder `data` contains data files (instances) from 4 routes (a route is identified by a unique seat, stations pair). Note you here have different datasets for the same route (e.g. from different days).

#### `r ctrQ()` 

Solve all the instances and store all the results in a tibble. How many instances are there for each route?


#### `r ctrQ()` 

Analyse the requests for each route, e.g. accepted, average length and distribution among slots. Comment on the results.



#### `r ctrQ()` 

Analyse the usage of the routes, e.g. usage, usage of seats and usage of slots. Comment on the results.


#### `r ctrQ()` 

Analyse how the number of requests affect the usage and number of accepted requests for each route. Comment on the results.