---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r, code = readLines("common.R"), cache = FALSE, include=FALSE}
```


# Transforming data {#sec-transform}

In this module we consider transformation of data. In general raw data may be messy and need to be structured in a __tidy__ way. Tidying your data means storing it in a structured form suitable for analysis. This is done using a tibble (data frame) where each column is a variable, and each row is an observation. Tidy data is important because the consistent structure lets you focus your struggle on questions about the data. 

Given a raw data set the first step is to clean it and and transform it to a tidy format. Given tidy data, you next often need to __transform__ it. Transformation includes narrowing in on observations of interest (e.g. only observations from a specific year or warehouse), creating new variables based on existing variables (like the cost of using the machine that day given idle time). Together, tidying and transforming are called __wrangling__, because it can be a hard process to get your data in the right form.

In this chapter you will learn how to work with tibbles using the [dplyr package][tidyverse-dplyr] which is a part of the [tidyverse][tidyverse-main-page]. 

## Learning outcomes {#lo-transform}

By the end of this module, you are expected to be able to:

* Describe what tidy and wangling is.
* Apply the most common string functions
* Apply tidy operations to data 
* Transform data
* Clean data

<!-- SOLO increasing: identify · memorise · name · do simple procedure · collect data · -->
<!-- enumerate · describe · interpret · formulate · list · paraphrase · combine · do -->
<!-- algorithms · compare · contrast · explain causes · analyse · relate · derive · -->
<!-- evaluate · apply · argue · theorise · generalise · hypothesise · solve · reflect -->


## Working with data in the tidyverse

An excellent introduction on how to transform data using the tidyverse is given in the interactive DataCamp course [Data Manipulation with dplyr][datacamp-r-dplyr]. Please complete the course before continuing. 

<!-- ## Tidy  -->


<!-- ## Wangling -->


<!-- https://learn.datacamp.com/projects/758 -->
<!-- https://learn.datacamp.com/courses/dealing-with-missing-data-in-r -->
<!-- https://learn.datacamp.com/courses/introduction-to-the-tidyverse -->


## Different learning paths {#lp-transform}

`r strLPath`

* Roger Peng provide a good video giving an [Introduction to the dplyr R package][video-dplyr]. 
* [Chapter 12](https://bookdown.org/rdpeng/rprogdatascience/managing-data-frames-with-the-dplyr-package.html) in @rdpeng provides a nice introduction to dplyr. 
* An alternative interactive DataCamp course is [Working with Data in the Tidyverse][datacamp-r-dplyr-bakeoff] which may be good to take if you need more training.
* The Data transformation with dplyr cheatsheet is very useful. Find the newest version in RStudio **Help > Cheatsheets**.


## Recap {#rc-transform}

* The package dplyr ...

   - The `filter` function chooses rows that meet a specific criteria. 
   - The `select` function chooses columns that we specify. 
   - The `arrange()` function reorders the rows in a data frame. 



* Extract variables with `select()`  
* Extract cases with `filter()`  
* Arrange cases, with `arrange()`  

* Make tables of summaries with `summarise()`  
* Make new variables, with `mutate()`  
* Do groupwise operations with `group_by()`

* Connect operations with `%>%`  

## Exercises {#ex-transform}

`r strExercises`

### Exercise (gapminder) {#ex-gapminder1}

Use the *exercise R markdown template* to solve this exercise (**File > New File > R Markdown...**, select **From template** and then **TFA Exercise**).

The gapminder data set provides values for life expectancy, GDP per capita, and population, every five years, from 1952 to 2007 for 142 countries. The data can be loaded using the gapminder package:

```{r message = FALSE, warning = FALSE}
library(gapminder)
gapminder
```

Let us try to examine the data set (use pipes `%>%` as much as possible). 

```{r, echo=FALSE}
addSolution("
gapminder %>% glimpse()
gapminder %>% summary()
gapminder %>% tail()
")
```

   (@) Use `glimpse`, `summary` and `tail` to examine the data.

   (@) Use `count` to count the number of
```{r, echo=FALSE}
addSolution("
gapminder %>% count(country) %>% nrow()
")
```
       a) countries, 
       b) continents,
```{r, echo=FALSE}
addSolution("
gapminder %>% count(continent) %>% nrow()
")
```
       c) countries per continent. 
```{r, echo=FALSE}
addSolution("
gapminder %>% count(continent, country) %>% count(continent)     # or
gapminder %>% distinct(continent, country) %>% count(continent)
")
```
   
```{r, echo=FALSE}
addSolution("
gapminder %>% distinct(continent) %>% pull(1) %>% as.character()
")
```   
   
   (@) Retrieve a vector with all distinct continent values.

   
   (@) Subset rows to find:
       a) all rows with life expectancy less that 29 years,
```{r, echo=FALSE}
addSolution("
dapminder %>% filter(lifeExp < 29)
")
```
       b) all rows for Rwanda after year 1979,
```{r, echo=FALSE}
addSolution('
gapminder %>% filter(country == "Rwanda", year > 1979)
')
```
       c) all rows for Rwanda, Afghanistan or France.
```{r, echo=FALSE}
addSolution('
gapminder %>%  filter(country %in% c("Rwanda", "Afghanistan", "France"))
')
```


   (@) Select columns 
       a) year and life expectancy,
```{r, echo=FALSE}
addSolution("
gapminder %>% select(year, lifeExp)
")
```       
       b) country and GDP per capita.
```{r, echo=FALSE}
addSolution("
gapminder %>% select(country, gdpPercap)
")
```       
      

```{r, echo=FALSE}
addSolution('
gapminder %>% 
   filter((gdpPercap > 40000 & continent == "Europe") | (gdpPercap < 400 & continent == "Africa")) %>% print(n=Inf) %>% 
   select(continent, country, gdpPercap) %>% 
   print(n=Inf)
')
```   

   (@) Subset your data set to find all rows with GDP per capita greater than 40000 in Europe or with GDP per capita less than 500 in Africa.

```{r, echo=FALSE}
addSolution('
gapminder %>%
  mutate(gdp = pop * gdpPercap)
')
```   

   (@) Use `mutate` to calculate each country's GDP (population times GDP per capita).

In general GDP numbers are large and abstract. Let us try to calculate relative numbers.

```{r, echo=FALSE}
addSolution('
mean_dk <- gapminder %>% filter(country == "Denmark") %>% pull(gdpPercap) %>% mean()
dat <- gapminder %>% mutate(gdpPercapRel = gdpPercap/mean_dk)
dat %>% 
  filter(country == "Denmark") %>% 
  select(country, year, gdpPercapRel)
summary(dat$gdpPercapRel)
', 
text = "The relative GDP per capita numbers are, in general, well below 1. We see that most of the countries covered by this dataset have substantially lower GDP per capita, relative to Denmark, across the entire time period.")
```  

   (@) Use `mutate` to calculate GDP per capita relative to mean GDP per capita in Denmark over the whole period (`gdpPercap` divided by the mean of Danish `gdpPercap`). Hint you first must calculate the mean of Danish `gdpPercap` and next use that to add a new column `gdpPercapRel`. Have a look at the calculated data for Denmark. Does the numbers seems reasonable? I perceive Denmark to be a "high GDP" country, so I predict that the distribution of `gdpPercapRel` is located below 1, possibly even well below. Check this intuition!


   (@) Use `arrange` to order 
      a) data by year then country, as opposed to current by country then year,
```{r, echo=FALSE}
addSolution('
gapminder %>% arrange(year, country)
')
``` 
      b) data from 2007, sorted on life expectancy,
```{r, echo=FALSE}
addSolution('
gapminder %>%
  filter(year == 2007) %>%
  arrange(lifeExp)
')
``` 
      c) data from 2007, sorted on life expectancy in **desc**ending order. Hint: use `desc()` inside `arrange`.
```{r, echo=FALSE}
addSolution('
gapminder %>%
  filter(year == 2007) %>%
  arrange(desc(lifeExp))
')
``` 


   (@) Use `select` to 
       a) rename `year` to `yr` and keep all other columns (the select helper `everything` may be used),
```{r, echo=FALSE}
addSolution('
gapminder %>% select(yr = year, everything())
')
```        
       b) remove `pop`
```{r, echo=FALSE}
addSolution('
gapminder %>% select(-pop)
')
```        
       c) reorder columns in order `year`, `pop`, ... (remaining).
```{r, echo=FALSE}
addSolution('
gapminder %>% select(year, pop, everything())
')
``` 

  (@) Use `group_by` and `summarize` to find the
      a) number of observations per continent
```{r, echo=FALSE}
addSolution('
gapminder %>% group_by(continent) %>% summarize(n = n())
')
```       
      b) number of countries per continent (use `n_distinct` inside `summarize` to count the number of distinct observations),
```{r, echo=FALSE}
addSolution('
gapminder %>% group_by(continent) %>% summarize(n = n(), n_countries = n_distinct(country))
')
```       
      c) average life expectancy by continent,
```{r, echo=FALSE}
addSolution('
gapminder %>% group_by(continent) %>% summarize(avg_lifeExp = mean(lifeExp))
')
```       
      d) minimum and maximum life expectancies seen by year in Asia 
```{r, echo=FALSE}
addSolution('
gapminder %>% filter(continent == "Asia") %>% group_by(year) %>% summarize(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))
')
``` 
      

```{r, echo=FALSE}
addSolution('
gapminder %>% 
  group_by(country) %>%                 # group by country
  select(country, year, lifeExp) %>%    # select relevant columns
  arrange(year, .by_group = TRUE) %>%   # make sure that data is sorted correct
  mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>%       
  filter(year < 1963)                   # just for nice printing
')
``` 

  (@) Sometimes you don't want to collapse the $n$ rows for each group into one row. That is, you don't want to use `summarize` but `mutate` within your groups. Try to make a new variable that is the years of life expectancy gained (lost) relative to 1952, for each individual country. You code should look like this
      ```{r, eval = FALSE}
      gapminder %>% 
        group_by(country) %>%                 # group by country
        select(country, year, lifeExp) %>%    # select relevant columns
        arrange(year, .by_group = TRUE) %>%   # make sure that data is sorted correct
        mutate(lifeExp_gain = ___) %>%        # define new variable
        filter(year < 1963)                   # just for nice printing
      ```
      The `first` function may be helpful to extract the first value from a vector in each group.


```{r, echo=FALSE}
addSolution('
gapminder %>%
  select(country, year, continent, lifeExp) %>%     
  group_by(continent, country) %>%                  
  mutate(le_delta = lifeExp - lag(lifeExp)) %>%
  summarize(worst_le_delta = min(le_delta, na.rm = TRUE)) %>%
  slice_min(worst_le_delta) %>%
  arrange(worst_le_delta)
')
``` 

  (@) Which country experienced the sharpest 5-year drop in life expectancy in each continent? Recall that the Gapminder data only has data every five years, e.g. for 1952, 1957, etc. So this really means looking at life expectancy changes between adjacent timepoints. Here the `lag` function is useful to select the value in the previous row. Your code should look like:
      ```{r, eval=FALSE}
      gapminder %>%
        select(country, year, continent, lifeExp) %>%             # select relevant columns
        group_by(continent, country) %>%                          # group
        mutate(le_delta = ___) %>%                                # within country, take (lifeExp in year i) - (lifeExp in year i - 1)
        summarize(worst_le_delta = min(___, na.rm = TRUE)) %>%    # find lowest value
        slice_min(worst_le_delta) %>%                             # find min in each continent
        arrange(worst_le_delta)                                   # arrange 
      ```
      Positive values of `le_delta` means lifeExp went up, negative means it went down. Break the code into pieces, starting at the top, and inspect the intermediate results. These commands are built up gradually, with lots of errors and refinements along the way. 



### Exercise (babynames) {#ex-babynames1}

Use the *exercise R markdown template* to solve this exercise (**File > New File > R Markdown...**, select **From template** and then **TFA Exercise**).

The package babynames contains a dataset provided by the USA social security administration:

* `babynames`: For each year from 1880 to 2017, the number of children of 
  each sex given each name. All names with more than 5 uses are given.
  (Source: http://www.ssa.gov/oact/babynames/limits.html)

Install it using 

```r
install.packages("babynames")
```

We will use the skimr package to get an overview over `babynames`:

```{r}
library(babynames)
library(skimr)
skim(babynames)
```

```{r, echo=FALSE}
addSolution(text = "The last line only selects the `n` column.")
``` 

  1) Which of these is NOT a way to select the `name` and `n` columns together?
      ```r
      select(babynames, -c(year, sex, prop))
      select(babynames, name:n)
      select(babynames, starts_with("n"))
      select(babynames, ends_with("n"))
      ```
  
  2) Use `filter` and the logical operators to find:
```{r, echo=FALSE}
addSolution('
babynames %>% filter(prop >= 0.08)
')
```   
        a) All of the names where prop is greater than or equal to 0.08  
```{r, echo=FALSE}
addSolution('
babynames %>% filter(name == "Sea")
')
```       
        b) All of the children named "Sea" 


  3) Use Boolean operators to return only the rows that contain:
      a) _Boys_ named Sue,
```{r, echo=FALSE}
addSolution('
babynames %>% filter(name == "Sue", sex == "M")
')
``` 
      b) Names that were used by exactly 5 or 6 children in 1880,
```{r, echo=FALSE}
addSolution('
babynames %>% filter(year == 1880, n == 5 | n == 6)
')
```       
      c) Names that are one of Acura, Lexus, or Yugo.
```{r, echo=FALSE}
addSolution('
babynames %>% filter(name %in% c("Acura", "Lexus", "Yugo"))
')
```       

```{r, echo=FALSE}
addSolution('
min(babynames$n)
max(babynames$n)
')
```  

  4) What is the smallest value of n? What is the largest?


```{r, echo=FALSE}
addSolution('
babynames %>% 
  filter(sex == "F", year == 2017) %>% 
  select(name, n) %>% 
  arrange(desc(n)) 
')
```  

  5) Write a sequence of functions that filters babynames to just the girls that were born in 2017, then selects the `name` and `n` columns, then, arranges the results so that the most popular names are near the top.


```{r, echo=FALSE}
addSolution('
babynames %>% 
  filter(sex == "M", name == "Lars")
')
```  

  6) Trim `babynames` to just the rows that contain your `name` and your `sex`.


 
```{r, echo=FALSE}
addSolution('
babynames %>% 
  filter(name == "Khaleesi") %>% 
  summarise(total = sum(n), first = min(year))
')
```  
```{r, echo=FALSE}
addSolution('
babynames ___ 
  filter(_______________________) ___
  ___________(total = ________, first = _______)
', title = "Hint")
``` 

  7) Complete the code below to extract the rows where `name == "Khaleesi"`. Then use `summarise()` to find the total number of children named Khaleesi and the first year Khaleesi appeared in the data.


```{r, echo=FALSE}
addSolution('
babynames %>%
  group_by(name, sex) %>% 
  summarize(total = sum(n)) %>% 
  arrange(desc(total))
')
```  
```{r, echo=FALSE}
addSolution('
babynames %>%
  _______(name, sex) %>% 
  _______(total = _____(n)) %>% 
  _______(desc(_____))
', title = "Hint")
``` 

  8) Use `group_by()`, `summarise()`, and `arrange()` to display the ten most popular names. Compute popularity as the *total* number of children of a single gender given a name. 
      
      
```{r, echo=FALSE}
addSolution('
babynames %>% 
  group_by(year) %>% 
  summarise(total = sum(n))
')
```  

  9) Use `group_by()` to calculate the total number of children born each year over time.


```{r, echo=FALSE}
addSolution('
babynames %>% 
  group_by(year, sex) %>% 
  mutate(rank = min_rank(desc(n))) %>% 
  arrange(year, sex, desc(prop))
', text = "The same results if you use `n` since in the same order.")
```  
```{r, echo=FALSE}
addSolution('
babynames %>% 
  group_by(___, ___) %>% 
  ___(rank = ___(desc(___))) %>% 
  arrange(year, sex, desc(prop))
', title = "Hint")
``` 

  10) Column `prop` denote the proportion given year and sex. Use `mutate()` and `min_rank()` to rank each row in babynames from _largest_ `prop` to lowest `prop` given year and sex. What happens if you do the same using the `n` column?


```{r, echo=FALSE}
addSolution('
babynames %>% 
  group_by(year, sex) %>% 
  mutate(rank = min_rank(desc(n))) %>% 
  filter(rank == 1, year > 2009)
')
```  

  11) Filter the results to find all names with `rank == 1` after 2009.














```{r links, child="links.md"}
```

### Exercise (profit) {#ex-profit1}

Consider the dataset profit:

```{r}
path <- system.file("extdata/profit_raw.csv", package = "tfa")
profit <- read_csv(path)
skim(profit)
```

Note that it seems that the dataset need to be cleaned. All columns are strings (some should be numbers) and there seems to be missing values. First you may try to have a view of the dataset in R using

```r
View(profit)
```

First focus on column `Quarter` which currently has 12 distinct values

```{r}
profit %>% distinct(Quarter)
```

You would like it to be values 1-4. 

  1) Use `mutate`, `str_remove` and `as.numeric` to convert the column to a numeric by removing all 'q' and 'Q' values.

```{r}
profit <- profit %>% mutate(Quarter = str_remove(Quarter, "q") %>% str_remove("Q") %>% as.numeric())
```

Let us look at the next columns

```{r}
profit %>% distinct(Channel) %>% pull()
profit %>% distinct(`Customer ID`) %>% pull()
profit %>% distinct(Country) %>% pull()
profit %>% distinct(`Product Line`) %>% pull()
```

These seems to be okay. The last columns should be numbers. Let us consider `Revenue`. 

```{r}
profit %>% distinct(Revenue) %>% pull()
```

Most values start with a dollar sign. Let us have a look at the other ones:

```{r}
profit %>% filter(!str_starts(Revenue, fixed("$"))) 
na_values <- profit %>% 
  filter(!str_starts(Revenue, fixed("$"))) %>% 
  distinct(Revenue) %>% 
  pull(Revenue)
```

The expression is a bit complex. Let us break it up. Function `fixed` just return the fixed string '$'. This is necessary since the dollar sign have a special meaning in regular expressions (beyond the scope here). Function `str_starts` check if the string starts with a dollar sign. We use the logical negation (NOT) to find complementary set. 

Note that different strings have been used to indicate `NA` values (`r na_values`). Let us first use a single value to indicate `NA` (a question mark):
```{r}
profit <- profit %>% mutate(Revenue = str_replace_all(Revenue, c("unknown" = "?", "Unknown" = "?")))
```

Next, we replace all `?` with `NA`:
```{r}
profit <- profit %>% mutate(Revenue = na_if(Revenue, "?"))
profit %>% filter(!str_starts(Revenue, fixed("$"))) 
```

Finally, we remove all dollar signs:

```{r}
profit <- profit %>% mutate(Revenue = str_remove(Revenue, fixed("$ ")) %>% as.numeric())
profit
```

As one pipe: 
```{r, eval=FALSE}
profit <- profit %>% 
  mutate(Revenue = str_replace_all(Revenue, c("unknown" = "?", "Unknown" = "?"))) %>% 
  mutate(Revenue = na_if(Revenue, "?")) %>% 
  mutate(Revenue = str_remove(Revenue, fixed("$ ")) %>% as.numeric())
```

  2) Convert the remaining columns to numeric like `Revenue`. 
  
  
  3) Use the `across` function to apply the operations in Question 2 for a set of columns. Hint: see the examples in on the help page of `across`. The code should look like:
```{r}
profit <- read_csv(path)
profit <- profit %>% 
  mutate(across(___:___, ~str_replace_all(.x, c("unknown" = "?", "Unknown" = "?")) )) %>% 
  mutate(across(___:___, ~na_if(.x, "?") )) %>% 
  mutate(across(___:___, ~str_remove(.x, fixed("$ ")) %>% as.numeric() )) 
profit
```

  4) Write one pipe that do all the cleaning


```{r}
profit <- read_csv(path) %>% 
  mutate(Quarter = str_remove(Quarter, "q") %>% str_remove("Q") %>% as.numeric()) %>% 
  mutate(across(Revenue:Profit, ~str_replace_all(.x, c("unknown" = "?", "Unknown" = "?")) )) %>% 
  mutate(across(Revenue:Profit, ~na_if(.x, "?") )) %>% 
  mutate(across(Revenue:Profit, ~str_remove(.x, fixed("$ ")) %>% as.numeric() )) 
skim(profit)
```

  5) Validate that revenue - product costs - customer service cost equals profit. If you see small rounding errors (less than or equal 1) then recalculate the profit.

```{r}
profit <- profit %>% 
  mutate(Profit_calc = Revenue - `Product Cost` - `Customer Service Cost`, Diff = abs(Profit - Profit_calc)) %>%  
  mutate(Profit = if_else(Diff == 1, Profit_calc, Profit, missing = Profit) ) 
profit %>% filter(is.na(Profit))
profit %>% filter(Diff == 1, is.na(Profit_calc))

```

  6) Recalculate values in columns `Revenue` - `Profit` if possible. 
```{r}
profit %>% rowwise() %>% mutate(c_na = sum(is.na(c_across(Revenue:Profit)))) %>% 
  mutate(Revenue = if_else(is.na(Revenue) & c_na == 1, Profit + `Product Cost` + `Customer Service Cost`, Revenue, Revenue),
         `Product Cost` = if_else(is.na(`Product Cost`) & c_na == 1, - Profit + Revenue - `Customer Service Cost`, `Product Cost`), 
         `Customer Service Cost` = if_else(is.na(`Customer Service Cost`) & c_na == 1, - Profit + Revenue - `Product Cost`, `Customer Service Cost`)) %>% rowwise() %>% mutate(c_na = sum(is.na(c_across(Revenue:Profit)))) %>% filter(c_na == 1)


profit %>% filter(is.na(Profit))

profit %>% filter(Diff == 1)
profit %>% filter(is.na(Diff))
```



```{r, eval=FALSE}
lines <- read_lines("test.txt", n_max = 3)
cat(lines, sep = "\n")
dat <- read_csv("test.txt")
write_csv(dat, "profit_char.csv")
skim(dat)

dat <- read_csv(
  "profit_char.csv",
  col_types = cols(Quarter = col_number(),
  Channel = col_character(),
  `Customer ID` = col_character(),
  Country = col_character(),
  `Product Line` = col_character(),
  Revenue = col_number(),
  `Product Cost` = col_number(),
  `Customer Service Cost` = col_number(),
  Profit = col_number())
                )

write_csv(dat, "profit_full.csv")

skim(dat)

# make messy
set.seed(42)
dat <- read_csv("test.txt")
idx <- sample(1:nrow(dat), round(runif(1)*500), replace = F)
dat$Quarter[idx] <- str_replace(dat$Quarter[idx], "Q", "")
idx <- sample(1:nrow(dat), round(runif(1)*500), replace = F)
dat$Quarter[idx] <- str_replace(dat$Quarter[idx], "Q", "q")

idx <- sample(1:nrow(dat), round(runif(1)*100), replace = F)
dat$Revenue[idx] <- ""
idx <- sample(1:nrow(dat), round(runif(1)*50), replace = F)
dat$Revenue[idx] <- "?"
idx <- sample(1:nrow(dat), round(runif(1)*50), replace = F)
dat$Revenue[idx] <- "unknown"
idx <- sample(1:nrow(dat), round(runif(1)*50), replace = F)
dat$Revenue[idx] <- "Unknown"

idx <- sample(1:nrow(dat), round(runif(1)*100), replace = F)
dat$`Customer Service Cost`[idx] <- "NA"
idx <- sample(1:nrow(dat), round(runif(1)*100), replace = F)
dat$`Customer Service Cost`[idx] <- "?"

idx <- sample(1:nrow(dat), round(runif(1)*100), replace = F)
dat$`Product Cost`[idx] <- ""

write_csv(dat, "profit_raw.csv")
```

